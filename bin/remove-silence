#!/usr/bin/env bash

set -e

# Function to display usage information
usage() {
    echo "Usage: $0 [-h] [-o output_dir] [-f output_file] [-m mode] [-v volume] [-t time] input_file"
    echo
    echo "Process silence in a video file using FFmpeg."
    echo
    echo "Options:"
    echo "  -h              Display this help message and exit"
    echo "  -o output_dir   Specify the output directory (default: current directory)"
    echo "  -f output_file  Specify the full output file path (overrides -o)"
    echo "  -m mode         Specify the processing mode: 'remove' or 'fastforward' (default: remove)"
    echo "  -v volume       Specify the volume threshold in dB (default: -50dB)"
    echo "  -t time         Specify the time threshold in seconds (default: 1)"
    echo "  input_file      The input video file to process"
}

# Parse command-line options
output_dir="."
output_file=""
mode="remove"
volume_threshold="-50dB"
time_threshold="1"

while getopts ":ho:f:m:v:t:" opt; do
    case ${opt} in
        h )
            usage
            exit 0
            ;;
        o )
            output_dir="$OPTARG"
            ;;
        f )
            output_file="$OPTARG"
            ;;
        m )
            mode="$OPTARG"
            ;;
        v )
            volume_threshold="$OPTARG"
            ;;
        t )
            time_threshold="$OPTARG"
            ;;
        \? )
            echo "Invalid option: -$OPTARG" 1>&2
            usage
            exit 1
            ;;
        : )
            echo "Option -$OPTARG requires an argument" 1>&2
            usage
            exit 1
            ;;
    esac
done
shift $((OPTIND -1))

# Check if input file is provided
if [ $# -eq 0 ]; then
    echo "Error: Input file is required" 1>&2
    usage
    exit 1
fi

input_file="$1"

# Check if input file exists
if [ ! -f "$input_file" ]; then
    echo "Error: Input file '$input_file' does not exist" 1>&2
    exit 1
fi

# Generate output file name if not specified
if [ -z "$output_file" ]; then
    input_filename=$(basename "$input_file")
    input_name="${input_filename%.*}"
    input_ext="${input_filename##*.}"
    output_filename="${input_name}_silence_removed.${input_ext}"
    output_file="${output_dir}/${output_filename}"
fi

# Ensure output directory exists
output_dir=$(dirname "$output_file")
mkdir -p "$output_dir"

fetch_silence_periods() {
  ffmpeg -i "$input_file" -hide_banner -vn -af silencedetect=noise="${volume_threshold}":d="${time_threshold}" -f null - 2>&1 \
    | grep "silence_end" \
    | awk '{print $5 " " $8}'
}

generate_silence_regions() {
  fetch_silence_periods \
    | ruby <(cat <<'EOF'
      silences = $stdin.read.split("\n").map(&:split)
      $stdout << silences.map { |silence|
        start_time = silence.first.to_f - silence.last.to_f + 0.25
        end_time = silence.first.to_f - 0.25

        next if start_time >= end_time

        "between(t,#{start_time},#{end_time})"
      }.compact.join("+")
EOF
    )
}

generate_filter_complex() {
  fetch_silence_periods \
    | ruby <(cat <<'EOF'
      silences = $stdin.read.split("\n").map(&:split)
      MediaRegion = Struct.new(:start_time, :end_time) do
        def valid?
          start_time < end_time
        end
      end

      class SilentRegion < MediaRegion
        def to_complex_filter(index)
        <<~FILTER
          [0:v]select='between(t,#{start_time},#{end_time})',setpts=0.5*(PTS-STARTPTS)[#{video_name_for_index(index)}];
          [0:a]aselect='between(t,#{start_time},#{end_time})',asetpts=0.5*(PTS-STARTPTS)[#{audio_name_for_index(index)}];
        FILTER
        end

        def video_name_for_index(index)
          "vs#{index}"
        end

        def audio_name_for_index(index)
          "as#{index}"
        end
      end

      class AudibleRegion < MediaRegion
        def to_complex_filter(index)
          <<~FILTER
            [0:v]select='between(t,#{start_time},#{end_time})',setpts=PTS-STARTPTS[#{video_name_for_index(index)}];
            [0:a]aselect='between(t,#{start_time},#{end_time})',asetpts=PTS-STARTPTS[#{audio_name_for_index(index)}];
          FILTER
        end

        def video_name_for_index(index)
          "va#{index}"
        end

        def audio_name_for_index(index)
          "aa#{index}"
        end
      end

      SilenceCollection = Struct.new(:silences) do
        include Enumerable

        def each
          silences.each do |silence|
            silence = SilentRegion.new(
              silence.first.to_f - silence.last.to_f + 0.25,
              silence.first.to_f - 0.25
            )

            next unless silence.valid?

            yield silence
          end
        end

        def each_region(&block)
          reduce([]) { |regions, silence|
            if regions.any?
              regions << AudibleRegion.new(regions.last.end_time, silence.start_time)
            end
            regions << silence
          }.each(&block)
        end
      end

      video_region_names = []
      audio_region_names = []
      $stdout << SilenceCollection.new(silences).each_region.each_with_index.map { |region, i|
        video_region_names << region.video_name_for_index(i)
        audio_region_names << region.audio_name_for_index(i)
        region.to_complex_filter(i)
      }.compact.join("\n")
      $stdout.puts "#{video_region_names.map { |name| "[#{name}]" }.join}concat=n=#{video_region_names.length}:v=1:a=0[outv];"
      $stdout.puts "#{audio_region_names.map { |name| "[#{name}]" }.join}concat=n=#{audio_region_names.length}:v=0:a=1[outa]"
EOF
    )
}

# Process silence using FFmpeg
if [ "$mode" = "remove" ]; then
    silence_periods=$(generate_silence_regions)

    ffmpeg -i "$input_file" \
      -vf "select='not($silence_periods)',setpts=N/FRAME_RATE/TB" \
      -af "aselect='not($silence_periods)',asetpts=N/SR/TB" \
      "$output_file"
    echo "Silence removed. Output file: $output_file"
elif [ "$mode" = "fastforward" ]; then

    ffmpeg -i "$input_file" \
      -filter_complex "$(generate_filter_complex)" \
      -map "[outv]" \
      -map "[outa]" \
      "$output_file"

    echo "Silent parts fast-forwarded. Output file: $output_file"
else
    echo "Error: Invalid mode. Use 'remove' or 'fastforward'." >&2
    exit 1
fi
